#!/bin/bash/env bash

#
# Filename:       auto-xorg
# Description:    Generates a config for X.Org (video output) for the first or
#                 last parsed, valid, non-VFIO video device (VGA).
# Author(s):      Alex Portell <github.com/portellam>
# Maintainer(s):  Alex Portell <github.com/portellam>
# Version:        1.1.3
#

#region Traps

trap 'catch_error' SIGINT SIGTERM ERR
trap 'catch_exit' EXIT

#endregion

#region Parameters

declare -r SCRIPT_VERSION="1.1.2"
declare -r SCRIPT_NAME="$( basename "${0}" )"
declare -r PREFIX_PROMPT="${SCRIPT_NAME}: "

SAVEIFS="${IFS}"
IFS=$'\n'

DISPLAY_MANAGER=$( cat /etc/X11/default-display-manager )
declare -r DISPLAY_MANAGER="${DISPLAY_MANAGER##*/}"
declare -r PATH_1="/etc/X11/xorg.conf.d/"
declare -r FILE_1="${PATH_1}10-auto-xorg.conf"

  #region Color coding

  # Reference URL : 'https://www.shellhacks.com/bash-colors'
  declare -r SET_COLOR_GREEN='\033[0;32m'
  declare -r SET_COLOR_RED='\033[0;31m'
  declare -r SET_COLOR_YELLOW='\033[0;33m'
  declare -r RESET_COLOR='\033[0m'

  #endregion

  #region Append output

  declare -r PREFIX_ERROR="${SET_COLOR_RED}An error occurred:${RESET_COLOR} "
  declare -r PREFIX_NOTE="${SET_COLOR_YELLOW}Note:${RESET_COLOR} "
  declare -r PREFIX_PASS="${SET_COLOR_GREEN}Success:${RESET_COLOR} "

  #endregion

  # DESC : Permanent Toggles
  HAS_MATCHED_INTEL_DRIVER=true

  # DESC : File contents
  declare -a FILE_1_CONTENTS=(
    "#### Generated by 'portellam/${SCRIPT_NAME}'"
    "# WARNING: Any modifications to this file will be modified by '${SCRIPT_NAME}'"
    "# Run lspci to view hardware information."
    "#"
  )

  #region Toggles

  DO_RESTART_DISPLAY_MANAGER=false
  PARSE_PCI_ORDER_BY_BUS_ID=true
  PREFER_AMD=false
  PREFER_INTEL=false
  PREFER_NVIDIA=false
  PREFER_OFF_BRAND=false
  PREFER_LISTED_BRAND=false
  MATCH_PROBLEM_DRIVER=false

  #endregion

  #region Evaluations

  GET_PCI_ID="lspci -m | grep --extended-regexp --ignore-case 'vga|graphics'"
  GET_PCI_ID+=" | cut --delimiter ' ' --fields 1"
  GET_PCI_ID_REVERSE_SORT="${GET_PCI_ID} | sort --reverse"

  #endregion

HWID_LIST=( )

#endregion

#region Logic

#
# $@  : the command line arguments.
# $?  : on success, exit 0; on failure, exit non-zero.
#
function main
{
  is_user_superuser

  if ! set_options "$@"; then
    print_usage
  fi

  toggle_sort_order_of_devices
  does_system_have_pci
  is_path_found
  is_file_deletable
  find_first_driver
  write_to_file
  restart_service

  if ! "${DO_RESTART_DISPLAY_MANAGER}"; then
    echo -e \
      "${PREFIX_NOTE}You may restart the active display manager"\
      "'${DISPLAY_MANAGER}'.\nTo restart, execute 'sudo systemctl"\
      "restart ${DISPLAY_MANAGER}'."
  fi

  exit 0
}

  #region Business logic

  #
  # $?  : on success, return 0; on failure, exit 1.
  #
  function does_system_have_pci
  {
    if [[ "${#HWID_LIST[@]}" -eq 0 ]]; then
      print_to_error_log "No PCI devices found."
      exit 1
    fi
  }

  #
  # $?  : on success, return 0; on failure, exit 1.
  #
  function find_first_driver
  {
    find_first_vga_driver && return 0
    PREFER_LISTED_BRAND=false
    print_to_error_log "Failed to find preferred VGA device."
    find_first_vga_driver && return 0
    print_to_error_log "No VGA devices found."
    exit 1
  }

  #
  # $?  : on success, return 0; on failure, return 1.
  #
  function find_first_vga_driver
  {
    for hwid in "${HWID_LIST[@]}"; do
      driver=$( \
        lspci -ks "${hwid}" \
          | grep --extended-regexp 'driver' \
          | cut --delimiter ':' --fields 2 \
          | cut --delimiter ' ' --fields 2 \
      )

      type=$( \
        lspci -ms "${hwid}" \
          | cut --delimiter '"' --fields 2 \
          | tr '[:upper:]' '[:lower:]' \
      )

      vendor=$( \
        lspci -ms "${hwid}" \
          | cut --delimiter '"' --fields 4 \
          | tr '[:upper:]' '[:lower:]' \
      )

      function_id=$( \
        echo "${hwid}" \
          | cut --delimiter '.' --fields 2 \
      )

      pci_id=$( \
        echo "${hwid}" \
          | cut --delimiter '.' --fields 1 \
      )

      pci_id+=":${function_id}"

      if match_valid_vga_device_with_driver "driver"; then
        match_driver_and_set_xorg_write_only "${driver}"
        return 0
      fi
    done

    return 1
  }

  #
  # $?  : on success, return 0; on failure, return 1.
  #
  function get_preferred_vendor
  {
    local -n reference="${1}"

    case true in
      "${PREFER_AMD}" )
        reference=$( \
          echo -e "${vendor}" \
            | grep --ignore-case --invert-match 'amd|ati' \
            | grep --ignore-case --invert-match 'corporation' \
        ) ;;

      "${PREFER_INTEL}" )
        reference=$( \
          echo -e "${vendor}" \
            | grep --ignore-case 'intel' \
        ) ;;

      "${PREFER_NVIDIA}" )
        reference=$( \
          echo -e "${vendor}" \
            | grep --ignore-case 'nvidia' \
        ) ;;

      "${PREFER_OFF_BRAND}" )
        reference=$( \
          echo -e "${vendor}" \
          | grep \
            --extended-regexp \
            --ignore-case \
            --invert-match \
            'amd|ati|intel|nvidia' \
      ) ;;

      * )
        print_to_error_log "Failed to match preferred vendor."
        return 1 ;;
    esac

    if ! is_string "${reference}" &> /dev/null; then
      return 1
    fi
  }

  #
  # $?  : on success, return 0; on failure, exit 1.
  #
  function is_file_deletable
  {
    if [[ -e "${PATH_1}" ]] \
      && ! sudo rm --force "${FILE_1}" &> /dev/null; then
      print_to_error_log "Failed to delete file '${FILE_1}'."
      exit 1
    fi
  }

  #
  # $1  : the path name.
  # $?  : if path found, return 0.
  #
  function is_path_found
  {
    if [[ ! -d "${PATH_1}" ]] \
      && sudo mkdir --parents "${PATH_1}"; then
      print_to_error_log "Failed to create directory '${PATH_1}'."
      exit 1
    fi
  }

  #
  # $1  : the driver.
  # $?  : always return 0.
  #
  function match_driver_and_set_xorg_write_only
  {
    local -r driver="${1}"

    case "${driver}" in
      *"nouveau"* )
        MATCH_PROBLEM_DRIVER=true ;;
    esac
  }

  #
  # $?  : on success, return 0; on failure, return 1.
  #
  function match_valid_vga_device_with_driver
  {
    local -r found_no_driver="Found Driver: 'N/A'"

    if ! is_string "${driver}" &> /dev/null \
      || ! is_string "${type}" &> /dev/null \
      || ! is_string "${vendor}" &> /dev/null; then
      print_to_output_log "${found_no_driver}"
      return 1
    fi

    if ! [[ "${type}" =~ ^"vga" ]] \
      && ! [[ "${type}" =~ ^"graphics" ]] ); then
      print_to_output_log "Skipped non-VGA device."
      return 1
    fi

    if [[ "${driver}" =~ ^"vfio-pci" ]]; then
      print_to_output_log "${found_no_driver}"
      return 1
    fi

    if "${PREFER_LISTED_BRAND}"; then
      local preferred_vendor=""
      get_preferred_vendor "preferred_vendor"

      if [[ "${preferred_vendor}" != "${vendor}" ]]; then
        print_to_output_log "${found_no_driver}"
        return 1
      fi
    fi

    match_vendor_and_override_driver "${vendor}"
    print_to_output_log "Found Driver: '${driver}'"
  }

  #
  # $1  : the driver.
  # $?  : always return 0.
  #
  function match_vendor_and_override_driver
  {
    local -r vendor="${1}"

    case "${vendor}" in
      *"intel"* )
        override_intel_vga_driver "${driver}" ;;
    esac
  }

  #
  # $1  : the reference.
  # $?  : always return 0.
  #
  function override_intel_vga_driver
  {
    local -n reference="${1}"
    local -r override_driver="modesetting"

    if "${HAS_MATCHED_INTEL_DRIVER}"; then
      reference="${override_driver}"

    else
      print_to_output_log \
        "Should given parsed Intel VGA driver be invalid, replace xorg.conf" \
        "with an alternate intel driver (example: '${override_driver}')."
    fi
  }

  #
  # $?  : on success, return 0; on failure, exit 1.
  #
  function restart_service
  {
    if "${DO_RESTART_DISPLAY_MANAGER}" \
      && ( \
        ! sudo systemctl enable "${FILE_2}" \
        || ! sudo systemctl restart "${FILE_2}" \
      ); then
      print_to_error_log "Failed to restart system service."
      exit 1
    fi

    print_to_output_log "Restarted system service."
  }

  #
  # $?  : on success, return 0; on failure, return 1.
  #
  function set_file
  {
    case "${?}" in
      0 )
        FILE_1_CONTENTS+=(
          ""
          "Section       \"Device\""
          "  Identifier  \"Device0\""
          "  Driver      \"${driver}\""
          "  BusID       \"PCI:${pci_id}\""
          "EndSection"
        )

        print_to_output_log "Valid VGA device found."
        ;;

      * )
        FILE_1_CONTENTS+=(
          ""
          "#Section       \"Device\""
          "#  Identifier  \"Device0\""
          "#  Driver      \"driver_name\""
          "#  BusID       \"PCI:bus_id:slot_id:function_id\""
          "#EndSection"
        )

        print_to_error_log "No valid VGA device found."
        ;;
    esac

    if ! echo -e "${FILE_1_CONTENTS[*]}" >> "${FILE_1}"; then
      print_to_error_log "Failed to write to file '${FILE_1}'."
      return 1
    fi

    print_to_output_log "Wrote to file '${FILE_1}'."
  }

  #
  # $?  : always returns 0.
  #
  function toggle_sort_order_of_devices
  {
    if "${PARSE_PCI_ORDER_BY_BUS_ID}"; then
      HWID_LIST=( $( eval "${GET_PCI_ID}" ) )

    else
      HWID_LIST=( $( eval "${GET_PCI_ID_REVERSE_SORT}" ) )
    fi
  }

  #
  # $?  : on failure, exit 1; on write failure, return 0.
  #
  function write_to_file
  {
    if [[ ! -d "${PATH_1}" ]]; then
      echo -e "${PREFIX_ERROR} Failed to create directory '${PATH_1}'."
      exit 1
    fi

    if ! "${MATCH_PROBLEM_DRIVER}"; then
      set_file || exit "${?}"

    else
      print_to_output_log "Not writing to file given presence of problem driver."
    fi
  }

  #endregion

  #region Options logic

  #
  # $1  : the option.
  # $?  : on success, return 0; on failure, return 1.
  #
  function get_option
  {
    while [[ "$1" =~ ^- && ! "$1" == "--" ]]; do case $1 in
      "-f" | "--first" )
        PARSE_PCI_ORDER_BY_BUS_ID=true ;;

      "-l" | "--last" )
        PARSE_PCI_ORDER_BY_BUS_ID=false
        print_to_output_log "Parsing VGA devices in reverse order." ;;

      "-r" | "--restart-display" )
        DO_RESTART_DISPLAY_MANAGER=true ;;

      "-a" | "--amd" )
        if "${PREFER_LISTED_BRAND}"; then
          return 1
        fi

        PREFER_AMD=true
        PREFER_LISTED_BRAND=true ;;

      "-i" | "--intel" )
        if "${PREFER_LISTED_BRAND}"; then
          return 1
        fi

        PREFER_INTEL=true
        PREFER_LISTED_BRAND=true ;;

      "-n" | "--nvidia" )
        if "${PREFER_LISTED_BRAND}"; then
          return 1
        fi

        PREFER_NVIDIA=true
        PREFER_LISTED_BRAND=true ;;

      "-o" | "--other" )
        if "${PREFER_LISTED_BRAND}"; then
          return 1
        fi

        PREFER_OFF_BRAND=true ;;

      "" )
        ;;

      "-h" | "--help" )
        return 1 ;;

      * )
        echo -e "${PREFIX_ERROR} Invalid input."
        return 1 ;;
    esac; shift; done

    if [[ "$1" == '--' ]]; then
      shift
    fi
  }

  #
  # $?  : always exits 1.
  #
  function print_usage
  {
    echo -e \
      "Usage: sudo ${SCRIPT_NAME} [OPTION]..." \
      "\n" \
      "  Generates X.Org (video output) for the first or last parsed valid "\
        "non-VFIO video device (VGA)." \
      "\n" \
      "  Version ${SCRIPT_VERSION}." \
      "\n" \
      "\n" \
      "    -h, --help\t\t\tPrint this help and exit." \
      "\n" \
      "\n" \
      "  Update X.Org:" \
      "\n" \
      "    -r, --restart-display\tRestart the display manager immediately." \
      "\n" \
      "\n" \
      "  Set device order:" \
      "\n" \
      "    -f, --first\t\tFind the first valid VGA device." \
      "\n" \
      "    -l, --last\t\tFind the last valid VGA device." \
      "\n" \
      "\n" \
      "  Prefer a vendor:" \
      "\n" \
      "    -a, --amd\t\tAMD or ATI" \
      "\n" \
      "    -i, --intel\t\tIntel" \
      "\n" \
      "    -n, --nvidia\tNVIDIA" \
      "\n" \
      "    -o, --other\t\tAny other brand (past or future)." \
      "\n" \
      "\n" \
      "  Example:" \
      "\n" \
      "    sudo ${SCRIPT_NAME} -f -a     Find first valid AMD/ATI VGA device." \
      "\n" \
      "    sudo ${SCRIPT_NAME} -l -n -r  Find last valid NVIDIA VGA device, then restart the display manager immediately."

    exit 1
  }

  #
  # $?  : on success, return 0; on failure, return 1.
  #
  function set_options
  {
    for option in "$@"; do
      is_string "${option}" &> /dev/null || return 0
      get_option "${option}" || return 1
    done
  }

  #endregion

  #region Clean-up

  #
  # $?  : always returns 0.
  #
  function reset_ifs
  {
    IFS="${SAVEIFS}"
  }

  #endregion

  #region Data-type validation

  #
  # $1  : the string.
  # $?  : if not empty string, return 0.
  #
  function is_string
  {
    if [[ "${1}" == "" ]]; then
      return 1
    fi
  }

  #endregion

  #region Handlers

  #
  # $?  : always exits non-zero.
  #
  function catch_error
  {
    exit 255
  }

  #
  # $?  : always returns 0.
  #
  function catch_exit
  {
    reset_ifs
  }

  #
  # $?  : if user is root, return 0.
  #
  function is_user_superuser
  {
    if [[ $( whoami ) != "root" ]]; then
      print_to_error_log "User is not sudo or root."
      return 1
    fi
  }

  #endregion

  #region Loggers

  #
  # $1  : the output.
  # $?  : always returns 0.
  #
  function print_to_error_log
  {
    echo -e "${PREFIX_PROMPT}${PREFIX_ERROR}${*}" >&2
  }

  #
  # $1  : the output.
  # $?  : always returns 0.
  #
  function print_to_output_log
  {
    echo -e "${PREFIX_PROMPT}${*}" >&1
  }

  #endregion

#endregion

#region Main

main "$@"

#endregion